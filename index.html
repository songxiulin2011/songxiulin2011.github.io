<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="xiulin"><title>xiulin's blog</title><meta name="description" content="和时间做朋友"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">xiulin's blog</a></h3><div class="description"><p>和时间做朋友</p></div></div></div><ul class="social-links"></ul><div class="footer"><a href="/"><span>你自己很清楚的知道未来会发生一件事</span></a><div class="by_farbox"><a href="/">但你一点儿也不担忧</a></div><div class="by_farbox"><a href="/">这件事会在什么时候发生</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/01/25/设计模式/">设计模式</a></h3></div><div class="post-content"><p>
每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样，你就能一次又一次的使用该方案而不必要做重复劳动。

一般而言，一个模式有四个基本要素：
1.模式名称
2.问题
3.解决方案
4.效果
订阅发布者模式（vue事件）策略模式
定义一系列的算法，把他们封装起来，并且使他们可以相互替换...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/01/25/被误解的闭包/">被误解的闭包</a></h3></div><div class="post-content"><p>
js 中的闭包是一个非常强大的特性，但是人们对其也有诸多误解。一种耸人听闻听闻的说法是闭包会造成内存泄漏，所以要尽量减少闭包的使用。


局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么局部变量就能一直生存下去。从这个意义上来看，闭包的确会使一些数据无法及时被销毁。使用闭...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-25</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/15/Map-、FlatMap-和-Reduce/">Map 、FlatMap 和 Reduce</a></h3></div><div class="post-content"><p>Map 作用是生成一个新的数组，遍历原数组，将每个元素拿出来做一些变换后 append 到新的数组中
12[1, 2, 3].map((v) = &gt; v + 1)// -&gt; [2, 3, 4]
Map 有三个参数，分别是当前索引元素，索引，原数组。1234['1', '2', '3'].map(par...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-15</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/15/Promise-的实现/">Promise 的实现</a></h3></div><div class="post-content"><p>Promise 是ES6新增的新语法，解决了回调地狱的问题。
可以把Promise看成一个状态机，初始是pending状态， 可以通过函数resolve和reject ，将状态转变为resolved或者rejected状态， 状态一旦改变就不能再次变化。
then函数会返回一个Promise实例， 并且该返回值是...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-15</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/14/call-apply-bind-的区别/">call apply bind 的区别</a></h3></div><div class="post-content"><p>首先说一下 call 和 apply 的区别
call 和 apply 都是为了解决改变this的指向。作用都是相同的，只是传参的方式不同。除了第一个参数外，call可以接收一个参数列表，apply只接收一个参数数组。
12345678910let a = &#123;  value: 1&#125;fun...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-14</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/13/JS中的防抖和节流/">JS中的防抖和节流</a></h3></div><div class="post-content"><p>防抖你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。
这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。
PS：防抖和节流的作用都是防止函数多次调用。区别在...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-13</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/09/计算机通识之网络协议（HTTP）/">计算机通识之网络协议（HTTP）</a></h3></div><div class="post-content"><p>TCP/IP协议 是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。
关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍

“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-09</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/08/计算机通识之网络协议（TCP）/">计算机通识之网络协议（TCP）</a></h3></div><div class="post-content"><p>TCP的三次握手为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手
知乎上的一个回答，从另外一个角度阐释：

在Google Groups的TopLanguage中看到一帖讨论TCP“三...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/09/08/计算机通识之网络协议（UDP）/">计算机通识之网络协议（UDP）</a></h3></div><div class="post-content"><p>UDPUDP是一个面向报文的协议，报文其实可以理解为一段段的数据，UDP只是报文的搬运工,不会对报文进行任何拆分和拼接操作。

在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头，标识一下是UDP协议，然后就传递给网络层了
在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2018/08/24/webpack配置之-服务和热更新/">webpack配置之 服务和热更新</a></h3></div><div class="post-content"><p>执行 npm install webpack-dev-server –save-dev对webpack.config.js 进行配置 配置如下12345678910devServer: &#123;  // 设置基本目录结构  contentBase: path.resolve(__dirname, 'dist'...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-08-24</span><i class="fa fa-tag"></i></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>