[{"title":"设计模式","url":"/2021/01/25/设计模式/","content":"> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样，你就能一次又一次的使用该方案而不必要做重复劳动。\n\n\n一般而言，一个模式有四个基本要素：\n\n1.模式名称\n\n2.问题\n\n3.解决方案\n\n4.效果\n\n#### 订阅发布者模式（vue事件）\n\n#### 策略模式\n> 定义一系列的算法，把他们封装起来，并且使他们可以相互替换\n\n策略模式的目的是将算法的使用和算法的实现分离开来\n\n\n```javascript\nvar strategies = {\n    \"s\": function (salary) {\n        return salary * 4\n    },\n    \"A\": function (salary) {\n        return salary * 3\n    },\n    \"B\": function (salary) {\n        return salary * 2\n    }\n}\n\nvar calculateBonus = function (level, salary) {\n    return strategies[level](salary)\n}\n```\n\n\n#### 单例模式（全局弹窗）\n\n#### 代理模式\n\n#### 中介者模式\n> 通过中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介对象即可。通过中介者模式可以接触对象与对象之间的紧耦合关系。\n\n中介者模式的实际业务场景\n\n- 购物车需求\n商品选择、颜色选择、购买数量等等都会触发订单change，那么可以通过中介者来转发处理这些事件，实现各个事件的解耦，仅仅维护中介者对象即可。\n\nredux、vuex都属于中介者模式的实际应用，我们把共享的数据，抽离成一个单独的store，每个都通过store这个中介来操作对象。\n\n\n#### 装饰器模式\n> 在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。\n\n常见应用，react的高阶组件，或者react-redux中的@connect或者自己定义一些高阶组件\n\n- 比如页面中有一个button，点击button会打开一个弹窗，同时会上报埋点数据用于统计button的点击次数。\n\n```javascript\n// 常规写法\n\nfunction showDialog () {\n    console.log('打开弹窗')\n    log(this.getAttribute('tag'))\n}\n\nfunction log (tag) {\n    console.log('上报埋点数据' + tag)\n}\n\ndocument.getElementById('button').onclick= showDialog\n\n// 装饰器写法\n\n// 先实现一个after\nFunction.prototype.after = function (afterfun) {\n    var __self = this\n    return function () {\n        var ret = __self.apply(this, arguments)\n        afterfun.apply(this, arguments)\n        return ret\n    }\n}\nfunction showDialog () {\n    console.log('打开弹窗')\n}\n\nfunction log () {\n    console.log('上报埋点数据' + this.getAttribute('tag'))\n}\n\nshowDialog = showDialog.after(log) // 打开弹窗后上报数据\n\ndocument.getElementById('button').onclick= showDialog\n```\nvue中的v-input v-checkbox 也可以认为是一种装饰器模式，对原生的input和checkbox做一层装饰\n\n\n#### 外观模式\n> 外观模式即让多个方法一起被调用\n\n涉及到兼容性、参数支持多格式，对外只暴露一个函数，内部判断实现\n\n\n#### 工厂模式\n> 提供创建对象的接口，把成员对象的创建工作交给一个外部对象，好处在于消除对象之间的耦合（也就是相互影响）\n\n常见例子： 弹窗、message、对外提供的api，都是调用api，然后新建一个弹窗或者message的实例，这些都是典型的工厂模式\n> 设计模式不能滥用 "},{"title":"被误解的闭包","url":"/2021/01/25/被误解的闭包/","content":"js 中的闭包是一个非常强大的特性，但是人们对其也有诸多误解。一种耸人听闻听闻的说法是闭包会造成内存泄漏，所以要尽量减少闭包的使用。\n\n局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么局部变量就能一直生存下去。从这个意义上来看，闭包的确会使一些数据无法及时被销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还要使用这些变量，把这些变量放在闭包中和放在全局作用域对内存的影响是一致的。这里并不能说成是内存泄漏。如果将来需要回收这些变量，手动把这些变量设为null就可以了。\n\n内存泄漏跟闭包有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些dom节点，这时候可能造成内存泄漏。但这本身并非是闭包的问题，也不是js的问题。在基于引用计数的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄漏在本质上也不是闭包造成的。"},{"title":"Map 、FlatMap 和 Reduce","url":"/2018/09/15/Map-、FlatMap-和-Reduce/","content":"`Map` 作用是生成一个新的数组，遍历原数组，将每个元素拿出来做一些变换后 `append` 到新的数组中\n\n```javascript\n[1, 2, 3].map((v) = > v + 1)\n// -> [2, 3, 4]\n```\n`Map` 有三个参数，分别是当前索引元素，索引，原数组。\n```javascript\n['1', '2', '3'].map(parseInt)\n//  parseInt('1', 0) -> 1\n//  parseInt('2', 1) -> NaN\n//  parseInt('3', 2) -> NaN\n```\nFlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维，可以将 FlatMap 看成是 map + flatten 目前该函数再浏览器中还不支持。\n```javascript\n[1, [2], 3].flatMap((v) => v + 1)\n// -> [2, 3, 4]\n```\n如果想将一个多维数组彻底降维，可以这样实现\n```javascript\nconst flattenDeep = (arr) => Array.isArray(arr)\n  ? arr.reduce( (a, b) => [...a, ...flattenDeep(b)] , [])\n  : [arr]\n\nflattenDeep([1, [[2], [3, [4]], 5]])\n```\nreduce 的作用是数组中的值结合起来，最终得到一个值\n```javascript\nfunction a() {\n  console.log(1)\n}\nfunction b() {\n  console.log(2)\n}\n[a, b].reduce((a, b) => a(b()))\n```"},{"title":"Promise 的实现","url":"/2018/09/15/Promise-的实现/","content":"Promise 是ES6新增的新语法，解决了回调地狱的问题。\n\n可以把Promise看成一个状态机，初始是`pending`状态， 可以通过函数`resolve`和`reject` ，将状态转变为`resolved`或者`rejected`状态， 状态一旦改变就不能再次变化。\n\n`then`函数会返回一个Promise实例， 并且该返回值是一个新的实例，而不是之前的实例。因为Promise规范规定除了`pending`状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个`then`调用就失去了意义。\n\n对于`then`来说，本质上可以把它看成是[flatMap](https://songxiulin2011.github.io/2018/09/15/Map-%E3%80%81FlatMap-%E5%92%8C-Reduce/)\n\n```javascript\n// 三种状态\nconst PENDING = 'pending'\nconst RESOLVED = 'resolved'\nconst REJECTED = 'rejected'\n// promise 接收一个函数作为参数，该函数会立即执行\nfunction MyPromise(fn) {\n  let _this = this\n  _this.currentState = PENDING\n  _this.value  = undefined\n  // 用于保存then中的回调，只有当promise状态为pending时才会缓存，并且每个实例至多缓存一个\n  _this.resolvedCallbacks = []\n  _this.rejectedCallbacks = []\n\n  _this.resolve = function (value) {\n    if (value instanceof MyPromise) {\n      // 如果 value 是个 Promise 则递归执行\n      return value.then(_this.resolve, _this.reject)\n    }\n    setTimeout(() => {\n      // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = RESOLVED\n        _this.value = value\n        _this.resolvedCallbacks.forEach(cb => cb())\n      }\n    })\n  }\n\n  _this.reject = function (reason) {\n    setTimeout(() => {\n      // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = REJECTED\n        _this.value = value\n        _this.rejectedCallbacks.forEach(cb => cb())\n      }\n    })\n  }\n\n  // 用于解决以下问题\n  // new Promise(() => throw Error('error'))\n  try {\n    fn(_this.resolve, _this.reject)\n  } catch (e) {\n    _this.reject(e)\n  }\n}\nMyPromise.prototype.then = function (onResolved, onRejected) {\n  var slef = this\n  // 规范 2.2.7 then必须返回的是一个新的promise\n  var promise2\n  // 规范2.2.x onResolved 和 onRejected 都为可选参数\n  // 如果类型不是函数需要忽略，同时也实现了透传\n  // Promise.resolve(4).then().then((value) => console.log(value))\n  onResolved = typeof onResolved === 'function' ? onResolved : v => v\n  onRejected = typeof onRejected === 'function' ? onRejected : r => throw r\n  if (self.currentState === RESOLVED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行\n      // 所以用了 setTimeout 包裹下\n      setTimeout(function () {\n        try {\n          var x = onResolved(self.value)\n          resolutionProcedure(promise2, x, resolve, reject)\n        } catch (reason) {\n          reject(reason)\n        }\n      })\n    }))\n  }\n\n  if (self.currentState === REJECTED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      setTimeout(function () {\n        // 异步执行onRejected\n        try {\n          var x = onRejected(self.value)\n          resolutionProcedure(promise2, x, resolve, reject)\n        } catch (reason) {\n          reject(reason)\n        }\n      })\n    }))\n  }\n\n  if (self.currentState === PENDING) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      self.resolvedCallbacks.push(function () {\n        // 考虑到可能会有报错，所以使用 try/catch 包裹\n        try {\n          var x = onResolved(self.value)\n          resolutionProcedure(promise2, x, resolve, reject)\n        } catch (r) {\n          reject(r)\n        }\n      })\n\n      self.rejectedCallbacks.push(function () {\n        try {\n          var x = onRejected(self.value)\n          resolutionProcedure(promise2, x, resolve, reject)\n        } catch (r) {\n          reject(r)\n        }\n      })\n    }))\n  }\n}\n// 规范 2.3\nfunction resolutionProcedure(promise2, x, resolve, reject) {\n  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n  if (promise2 === x) {\n    return reject(new TypeError(\"Error\"))\n  }\n  // 规范 2.3.2\n  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n  if (x instanceof MyPromise) {\n    if (x.currentState === PENDING) {\n      x.then(function (value) {\n        // 再次调用该函数是为了确认 x resolve 的\n        // 参数是什么类型，如果是基本类型就再次 resolve\n        // 把值传给下个 then\n        resolutionProcedure(promise2, value, resolve, reject)\n      }, reject)\n    } else {\n      x.then(resolve, reject)\n    }\n    return\n  }\n  // 规范 2.3.3.3.3\n  // reject 或者 resolve 其中一个执行过得话，忽略其他的\n  let called = false\n  // 规范 2.3.3，判断 x 是否为对象或者函数\n  if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n    // 规范 2.3.3.2，如果不能取出 then，就 reject\n    try {\n      // 规范 2.3.3.1\n      let then = x.then\n      // 如果 then 是函数，调用 x.then\n      if (typeof then === \"function\") {\n        // 规范 2.3.3.3\n        then.call(\n          x,\n          y => {\n            if (called) return\n            called = true\n            // 规范 2.3.3.3.1\n            resolutionProcedure(promise2, y, resolve, reject)\n          },\n          e => {\n            if (called) return\n            called = true\n            reject(e)\n          }\n        )\n      } else {\n        // 规范 2.3.3.4\n        resolve(x)\n      }\n    } catch (e) {\n      if (called) return\n      called = true\n      reject(e)\n    }\n  } else {\n    // 规范 2.3.4，x 为基本类型\n    resolve(x)\n  }\n}\n```"},{"title":"call apply bind 的区别","url":"/2018/09/14/call-apply-bind-的区别/","content":"首先说一下 **call** 和 **apply** 的区别\n\n**call** 和 **apply** 都是为了解决改变this\b的指向。作用都是相同的，只是传参的方式不同。除了第一个参数外，\b**call**可以接收一个参数列表，**apply**只\b接收一个参数数组。\n\n```javascript\nlet a = {\n  value: 1\n}\nfunction getValue (name, age) {\n  console.log(name)\n  console.log(age)\n  console.log(this.value)\n}\ngetValue.call(a, 'yck', '12')\ngetValue.apply(a, ['yck', '12'])\n```\n#### 模拟实现call和apply\n可以从以下几点来考虑如何实现\n\n- 不传如入第一个参数，那么默认window\n- 改变this的指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完后可以删除？\n```javascript\nFunction.prototype.myCall = function () {\n  var context = context || window\n  // 给context添加一个属性\n  // getVaule.call(a, 'yck', '12') => a.fn = getValue\n  context.fn = this\n  // 将 context 后面的参数取出来\n  var args = [...arguments].slice(1)\n  // getValue.call(a, 'yck', '12') => a.fn('yck', '12')\n  var result = context.fn(...args)\n  // 删除fn\n  delete context.fn\n  return result\n}\n```\n以上是call的思路，apply的实现也类似\n```javascript\nFunction.prototype.myApply = function (context) {\n  var context = context || window\n  context.fn = this\n\n  var result\n  // 需要判断是否存储第二个参数\n  // 如果存在，就将第二个参数展开\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n\n  delete context.fn\n  return result\n}\n```\n**bind** 和其他\b两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过\b **bind** 实现柯里化。\n\n同样的，我们也来模拟实现下 **bind**\n```javascript\nFunction.prototype.myBind = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  var _this = this\n  var args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n```"},{"title":"JS中的防抖和节流","url":"/2018/09/13/JS中的防抖和节流/","content":"#### 防抖\n你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。\n\n这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。\n\nPS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。\n\n我们先来看一个袖珍版的防抖理解一下防抖的实现：\n\n```javascript\n// func是用户传入需要防抖的函数\n// wait是等待时间\nconst debounce = (func, wait = 50) => {\n  // 缓存一个定时器id\n  let timer = 0\n  // 这里返回的函数是每次用户实际调用的防抖函数\n  // 如果已经设定过定时器了就清空上一次的定时器\n  // 开始一个新的定时器，延迟执行用户传入的方法\n  return function(...args) {\n    if (timer) clearTimeout(timer)\n    timer = setTimeout(() => {\n      func.apply(this, args)\n    }, wait)\n  }\n}\n// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数\n```\n这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用，一般的防抖会有immediate选项，标识是否立即调用，这两者的区别，举个例子来说：\n\n- 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用 **延迟执行** 的防抖函数，它总是在一连串（间隔小于wait的）函数出发之后调用。\n- 例如用户给 某个github项目点star的时候，我们希望用户点的第一下的时候就去调用接口，并且成功之后改变star按钮的样式，用户就可以立马得到反馈是否star成功了，这个情况适用 **立即执行** 的防抖函数，它总是第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。\n\n下面实现了一个带有立即执行选项的防抖函数\n\n```javascript\nfunction now () {\n  return +new Date()\n}\n/**\n  * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于wait，func才会执行\n  * @param {function} func   回调函数\n  * @param {number} wait 表示时间窗口的间隔\n  * @param {boolean} immediate  表示是否立即调用函数\n  * @return {function} 返回客户调用函数\n  */\nfunction debounce (func, wait = 50, immediate = true) {\n  let timer, context, args\n\n  // 延迟执行函数\n  const later = () => setTimeout(() => {\n    // 延迟执行函数执行完毕，清空缓存的定时器序号\n    timer = null\n    // 延迟执行的情况下，函数会在延迟函数中执行\n    // 使用到之前缓存的参数和上下文\n    if (!immediate) {\n      func.apply(context, args)\n      context = args = null\n    }\n  }, wait)\n\n  // 这里返回函数是每次实际调用的函数\n  return function (...params) {\n    // 如果没有创建延迟执行函数（later），就创建一个\n    if (!timer) {\n      timer = later()\n      // 如果是立即执行，调用函数\n      // 否则缓存参数和调用上下文\n      if (immediate) {\n        func.apply(this, params)\n      } else {\n        context = this\n        args = params\n      }\n      // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个\n      // 这样做延迟函数会重新计时\n    } else {\n      clearTimeout(timer)\n      timer = later()\n    }\n  }\n}\n```\n整体函数的实现并不难，总结一下：\n - 对于按钮防点击来说的实现： 如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行，一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点lei了，定时器时间到，定时器重置为null，就可以再次点击了。\n - 对于延迟执行的函数来说：清楚定时器，如果是延迟调用就调用函数\n\n#### 节流\n防抖和节流本质是不一样的，防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。\n```javascript\n/**\n  * underscore 节流函数，返回函数连续调用时，func执行频率限定为 次/wait\n  * @param {function} func 回调函数\n  * @param {number} wait 表示时间窗口的间隔\n  * @param {object} options 如果想忽略开始函数的调用，传入 {leading: false}\n  *                          如果想忽略结尾函数的调用，传入{trailing: false}\n  *                          两者不能共存，否则函数不能执行\n  *@return {funciton}        返回客户调用函数\n  */\n_.throttle = function (func, wait, options) {\n  var context, args, result\n  var timeout = null\n  // 之前的时间戳\n  var previous = 0\n  if (!options) options = {}\n  var later = function () {\n    // 如果设置了 leading 就将 previous 设为 0\n    // 用于下面函数的第一个 if 判断\n    previous = options.leading === false ? 0 : _.now()\n    // 置空一是为了防止内存泄露 二是为了下面的定时器判断\n    timeout = null\n    result = func.apply(context, args)\n    if (!timeout) context = args = null\n  }\n  return function () {\n    // 获取当前时间戳\n    var now = _.now()\n    // 首次进入前者肯定为 true\n    // 如果需要第一次不执行函数\n    // 就将上次时间戳设为当前的\n    // 这样在接下来计算 remaining 的值时会大于0\n    if (!previous &&　options.leading === false) previous = now\n    // 计算剩余时间\n    var remaining = wait - (now - previous)\n    context = this\n    args = arguments\n    // 如果当前调用已经大于上次调用时间 + wait\n    // 或者用户手动调了时间\n    // 如果设置了 trailing，只会进入这个条件\n    // 如果没有设置 leading，那么第一次会进入这个条件\n    // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n    // 其实还是会进入的，因为定时器的延时\n    // 并不是准确的时间，很可能你设置了2秒\n    // 但是他需要2.2秒才触发，这时候就会进入这个条件\n    if (remaining <= 0 || remaining > wait) {\n      // 如果存在定时器就清理掉否则会调用二次回调\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      previous = now\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    } else if (!timeout && options.trailing !== false) {\n      // 判断是否设置了定时器和 trailing\n      // 没有的话就开启一个定时器\n      // 并且不能不能同时设置 leading 和 trailing\n      timeout = setTimeout(later, remaining)\n    }\n    return result\n  }\n}\n```"},{"title":"计算机通识之网络协议（HTTP）","url":"/2018/09/09/计算机通识之网络协议（HTTP）/","content":"TCP/IP协议 是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。\n\n关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍\n>“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”\n\n术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。\n>“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\nHTTP(超文本传输协议)看到这里，前端同学肯定有一种莫名的熟悉感觉，对！我们的HTML（超文本标记语言），也从一方面体现了我们前端跟HTTP协议打交道的机会特别多，HTTP是利用TCP在两台电脑（通常是web服务器和客户端）之间传输信息的协议。客户端使用web浏览器发起HTTP请求给web服务器，web服务器发送被请求的信息给客户端。\n\n下面的表格中列举了不同的TCP/IP和其他的协议在最初OSI模型中的位置\n\n\n| 位置        | 协议   |\n| --------   | -----:  |\n| 应用层        | 例如HTTP、SMTP、FTP、SSH   |\n| 表示层        | 例如XDR、ASN   |\n| 会话层        |   例如SSH、RPC   |\n| 传输层        |    例如TCP、UDP、RTP    |\n| 网络层        |    例如IP    |\n| 数据链路层     |    例如以太网    |\n| 物理层        |    例如线路、无线电、光纤    |\n\nHTTP是我们前端最熟悉也是接触最多的网络通信协议，所以这里\b做一下详细介绍\n#### HTTP协议的几个重要概念\n1.连接（connection）：一个传输层的实际环流，它是建立在两个互通的应用程序之间。\n\n2.消息（message）：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。\n\n3.请求（request）：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。\n\n4.响应（response）：一个从服务器返回的信息。其中包含HTTP协议的版本号、请求的状态（例如200 或 404）和文档的MIME类型\n\n5.资源（resource）：由URL标识的网络数据对象或者服务。\n\n6.实体（\bentity）：数据资源或来自服务器资源的回映的\b一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体本身的内容。\n\n7.\b客户机（client）：一个为发送请求目的而建立连接的应用程序。\n\n8.用户代理（useragent）：初始化一个请求的客户机，它们是浏览器、编辑器、或者是其他用户工具。\n\n9.服务器（server）：一个接受连接请求、并对请求返回信息的应用程序。\n\n10.源服务器（originserver）：是一个给定资源可以在其上驻留或被创建的服务器。\n\n11.代理（proxy）：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其他客户机建立请求。请求是通过可能的内部翻译或经过传递到其他的服务器中。\n\n12.网关（gateway）：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好像对请求的资源来说它就源服务器。发出请求的客户机并没有意识到它在同网管打交道。\n\n13.通道（tunnel）：是作为两个连接中继的中介程序。一旦被激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。\n\n14.缓存(Cache)：反应信息的局域存储。"},{"title":"计算机通识之网络协议（TCP）","url":"/2018/09/08/计算机通识之网络协议（TCP）/","content":"### TCP的三次握手\n![](../images/tcp.png)\n为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手\n\n知乎上的一个回答，从另外一个角度阐释：\n>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足\"在不可靠信道上可靠地传输信息\"这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。\n\n### TCP 是什么？\nTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n\n#### 为什么要三次握手\n>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。\n\n\b我们作为前端经常听说三次握手 殊不知还有四次挥手\n\nTCP连接的拆除需要发送四个包，因此成为四次挥手（four-way handshake）客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。\n\n#### 为什么建立连接协议是三次握手，而关闭连接却是四次握手\n\n这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。"},{"title":"计算机通识之网络协议（UDP）","url":"/2018/09/08/计算机通识之网络协议（UDP）/","content":"\n### UDP\nUDP是一个面向[报文](https://wiki.mbalib.com/wiki/%E6%8A%A5%E6%96%87)的协议，报文其实可以理解为一段段的数据，UDP只是报文的搬运工,不会对报文进行任何拆分和拼接操作。\n* 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头，标识一下是UDP协议，然后就传递给网络层了\n* 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作\n\n### 不可靠性\n* UDP是无连接的，也就是说通信不需要建立连接和断开连接\n* UDP是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的\n* UDP没有拥塞控制，一直会以恒定的速度发送数据。即使网络不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能导致丢包，但是优点也很明显，在某些实时性要求高的场景（直播、电话会议）就需要使用UDP而不是TCP\n\n### 高效性\n因为UDP没有TCP复杂，需要保证数据不丢失且有序到达。所以UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少多了，在数据传输报文时是高效的。\n头部包含了以下几个数据\n- 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n- 整个数据报文的长度\n- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误\n\n### 传输方式\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n\n"},{"title":"webpack配置之 服务和热更新","url":"/2018/08/24/webpack配置之-服务和热更新/","content":"执行 npm install webpack-dev-server --save-dev \n对webpack.config.js 进行配置 配置如下\n```javascript\ndevServer: {\n  // 设置基本目录结构\n  contentBase: path.resolve(__dirname, 'dist'),\n  // 服务器的IP地址，可以使用IP也可以使用localhost\n  host: 'localhost',\n  // 服务端压缩是否开启\n  compress: true,\n  // 配置服务端口号\n  port: 8088\n}\n```"},{"title":"webpack配置之 入口出口","url":"/2018/08/18/webpack配置之-入口出口/","content":"### 配置文件 webpack.config.js\nwebpack.config.js 就是webpack的配置文件 这个文件需要自己在项目根目录下手动创建。文件大致结构如下\n```javascript\nmodule.exports = {\n    // 入口文件的配置项 可以是单一的入口 也可以是多入口\n    entry: {},\n    //出口文件的配置项 支持多出口配置\n    output: {},\n    //模块： 例如css 图片如何转换 压缩\n    module: {},\n    //插件：用于生产模版和各项功能\n    plugins: [],\n    //配置webpack开发服务功能\n    devServer: {}\n}\n```\n### entry 选项（入口配置）\n这个选项就是我们配置我们要压缩的文件一般是 javascript 文件 （也可以是css） \nwebpack.config.js 中的entry 选项\n```javascript\n// 入口文件的配置项\nentry: {\n    entry: './src/index.js' // index.js 这里的路径可以随意指定\n}\n```\n### output选项 （出口配置）\n出口配置是用来告诉webpack最后打包文件的地址和文件名称的。一般都是打包到一个叫做 dist 文件的目录下 代码如下\n```javascript\n// 出口文件的配置\noutput: {\n    path: path.resolve(_dirname, 'dist'),\n    filename: 'bundle.js'\n}\n```\n### 多入口 多出口配置\n配置文件如下\n```javascript\nconst path = require('path')\nmodule.exports = {\n  entry: {\n    entry: './src/index.js',\n    entry2: './src/other.js'\n  },\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n  module: {},\n  plugins: [],\n  devServer: {}\n}\n```"},{"title":"编码技巧","url":"/2018/05/28/编码技巧/","content":"# 三元操作符\n如果使用if ... else 语句 那么这是一个很好的节省代码的方式\n比如\n```javascript\nconst x = 20\nlet answer\nif (x > 10) {\n    answer = 'is greater'\n} else {\n    answer = 'is lesser'\n}\n```\n可以缩短为下面的一行代码\n```javascript\nconst answer = x > 10 ? 'is greater' : 'is lesser'\n```\n分配一个变量值到另一个变量值的时候，你可能想要确保变量不是null 、undefined 或 空。你可以写一个有多个if的条件语句\n```javascript\nif (value !== null || value !== undefined || value !== ''){\n    let newValue = value\n}\n```\n但是下面的书写方式更简洁\n```javascript\nconst newValue = value || 'new'\n```\n\n# js 的for循环\n如果你只想要用原生的javascript 普通的写法如下\n```javascript\nconst array = ['1','2','3']\nfor (let i = 0; i < array.length; i ++){\n    console.log(array[i])\n}\n```\n更简洁的写法\n```javascript\nconst array = ['1','2','3']\nfor (let index in array){\n    console.log(array[index])\n}\n```\n# Array.forEach()简写\n```javascript\nfunction logArrayElements(element, index, array){\n    console.log(\"a[\" + index + \"]=\" + element)\n}\n[2, 5, 9].forEach(logArrayElements)\n```\n# 十进制指数\n你可能看过这个 它本质上是一个写数字的奇特写法，就是一个数字后面有很多个0 例如1e7 本质相当于10000000 （1的后面有7个0）那么像这样的代码\n```javascript\nfor (let i = 0; i < 10000; i ++ ){\n    console.log(i)\n}\n```\n就可以简写成这个样子\n```javascript\nfor (let i = 0 ; i < 1e4; i ++){\n    console.log(i)\n}\n```\n# 箭头函数\n经典函数很容易读和写，但是确实有点冗长，特别是嵌套函数中调用其他函数时还会让你困惑\n```javascript\nfunction sayHello (name) {\n    console.log('Hello , ' + name)\n}\nsetTimeout(function () {\n    console.log('Loaded')\n}, 2000)\nlist.forEach(function(item) {\n    console.log(item)\n})\n```\n简写成如下\n```javascript\nsayHello = name => console.log('Hello, ' + name)\nsetTimeout(() => console.log('Loaded'), 2000)\nlist.forEach(item => console.log(item))\n```\n# 隐式返回\nreturn 是在函数中经常使用到的一个关键词，将返回函数的最终结果。箭头函数用一个语句将隐式的返回结果（为了省略return关键词 函数必须省略{}），如果返回一个多行语句（比如对象），有必要在函数体内使用（）代替{}。这样可以确保代码是否作为一个单独的语句返回。\n```javascript\nfunction calcCircunference (diameter) {\n    return Math.PI * diameter\n}\n```\n可以简写成下面这种\n```javascript\nconst calcCircunference = diameter => (\n    Math.PI * diameter\n)\n```\n# 参数默认值\n```javascript\nconst vaolume = (l, w = 3, h =4)  => (l * w * h)\n```\n# 模版字符串\n```javascript\n//  普通字符串\n`In JavaScript '\\n' is a line-feed`\n// 多行字符串\n`In JavaScript this is \nnot legal`\n//  字符串中嵌入变量\nlet name = 'Bob', time = 'today'\n`Hello ${name}, how are you ${time}`\n```"},{"title":"数据结构与算法（一）","url":"/2018/05/25/数据结构与算法（一）/","content":"\n### 数据结构（程序=数据结构 +  算法）\n数据结构就是关系， 就是数据元素相互直接存在的一种或多种特定关系的集合。\n传统上，我们把数据结构分为逻辑结构和物理结构。\n逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题。\n物理结构：是指数据的逻辑结构在计算机中的存储形式。\n常用的数据结构有：\n\n\n数组（array）,队列（queue），堆（heap），栈（stack），链表（linked list），树（tree），图（graph）和散列表（hash）。\n\n栈（stack）：运算只在表的一端进行；\n队列（queue）：运算只在两端进行，只允许在一端进行插入操作，而在另一端进行删除操作的线性表。\n与栈相反，队列是一种先进先出（Frist in Frist out 　ＦＩＦＯ）的线性表。\n与栈相同的是，队列是一种重要的线性结构，实现一个队列同样需要顺序表或链表作为基础。\n四大结构\n### 集合结构\n![](../images/24172510.png)\n###  线性结构\n![](../images/24207018.png)\n### 树形结构 \n![](../images/24233288.png)\n### 图形结构\n\n顺序存储和链式存储\n数据元素的存储结构形式有两种：顺序存储和链式存储。\n例如 我们编程语言的数组结构就是这样的\n\n 链式存储结构：是把数据元素存放在任意的存储单元里。这组存储单元可以是连续的，也可以是不连续的。\n链式存储结构\n\n \n线性表\n线性表：就好像是排队一样，具有线一样的性质的结构，它是由零个或多个数据元素组成的有限序列。\n若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他的元素都有且只有一个前驱和后继。\n若将线性表记为（a1......ai-1,ai,ai+1,....an）,则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。\n\n\n数据类型\n数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。\n\n例如很多编程语言的整型，浮点型，字符型。。。这些指的就是数据类型。\n\n在计算机中，内存不是无限大的，如果要计算或者处理一些比较大的数时，需要开辟比较大的内存空间，于是就要对计算机进行数据类型的分类，分出多种数据类型来适合各种不同的计算条件差异。\n\n在c语言中 数据类型可以分为两类：\n原子类型：不可以再分解的基本类型，例如整型，浮点型，字符型等\n结构类型：由若干个类型的组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。\n\n\n算法\n \n算法是解决特定问题的求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。\n算法是具有五个基本特征：输入、输出、有穷性、确定性、和可行性。\n输出：算法至少有一个或者多给输出。\n有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。\n确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。\n可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。\n正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。\n高级语言编写的程序在计算机运时所消耗的时间取决于下列因素：\n\n1.算法采用的策略，方案。\n2.编译产生的代码质量。\n3.问题的输入模式。\n4.机器执行指令的速度。\n\n我们可以想象，线性表有两种物理存储结构：顺序存储结构和链式存储结构。\n\n线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。\n\n顺序存储结构封装需要三个属性：\n\n存储空间的起始位置：数组data，它的存储位置就是线性表存储空间的存储位置。\n线性表的最大存储容量：数组的长度MaxSize。\n线性表的当前长度：length。\n","tags":["life"]}]